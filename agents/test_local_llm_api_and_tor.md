# Скрипт `agents/test_local_llm_api_and_tor.py`

**Назначение:**  
Данный скрипт демонстрирует, как в одном проекте можно проверять внешний IP с помощью TOR-прокси и одновременно обращаться к локально развёрнутой модели (Ollama) напрямую **без** использования TOR.

## Оглавление
1. [Краткое описание](#краткое-описание)
2. [Задачи, которые решает скрипт](#задачи-которые-решает-скрипт)
3. [Принцип работы](#принцип-работы)
   - [Уровень прокси и почему не подходит глобальная подмена `socket.socket`](#уровень-прокси-и-почему-не-подходит-глобальная-подмена-socketsocket)
   - [Схема обхода TOR для локального IP](#схема-обхода-tor-для-локального-ip)
4. [Настройка и запуск](#настройка-и-запуск)
5. [Пример логов работы](#пример-логов-работы)
6. [Как использовать ту же логику в других скриптах](#как-использовать-ту-же-логику-в-других-скриптах)

---

## Краткое описание

Этот скрипт пошагово делает следующее:

1. **Проверяет**, запущен ли сервис TOR в системе (через `systemctl is-active tor`).
2. **Отключает TOR** на уровне сессии (session-level) и выполняет несколько действий:
   - Узнаёт свой внешний IP (через [https://api.ipify.org](https://api.ipify.org)),
   - Шлёт тестовый запрос к локальному Ollama по адресу `http://10.67.67.2:11434/api/generate`.
3. **Включает TOR** (session-level) и снова проверяет свой IP (он должен измениться на IP exit-нода),
   но при этом **обращение** к Ollama (локальный IP `10.67.67.2`) по-прежнему идёт **без** TOR, чтобы избежать ошибки «General SOCKS server failure».
4. В завершение (опционально) снова **выключает TOR** и выводит финальный IP.

Таким образом, вы видите, что TOR включается для **внешних** запросов (например, к ipify), но **не** используется для локальных.

---

## Задачи, которые решает скрипт

1. **Продемонстрировать** включение и выключение TOR в рамках одного приложения.
2. **Проверить**, что локальная модель Ollama **не ломается**, если TOR включён, ведь локальные IP-адреса по умолчанию недоступны через exit-ноды TOR.
3. **Показать**, как сохранять гибкость:  
   - «Внешний трафик» (к API, проверки IP и т.д.) идёт через TOR, когда вы того хотите,  
   - а «локальные запросы» всегда идут напрямую, независимо от TOR.

---

## Принцип работы

### Уровень прокси и почему не подходит глобальная подмена `socket.socket`

В некоторых примерах (или библиотеках) для включения TOR делают так:

```python
import socks
import socket

socks.set_default_proxy(socks.SOCKS5, "localhost", 9050)
socket.socket = socks.socksocket
```

Это **глобально** перенаправляет **все** соединения через TOR. В таком режиме любой запрос к адресу вида `10.x.x.x` провалится с ошибкой `General SOCKS server failure`, так как локальные IP не маршрутизируются через публичный exit-нод TOR.

**В нашем скрипте** мы избегаем этого, используя **session-level proxies**. То есть:

```python
session = requests.Session()
session.proxies = {
    "http": "socks5://127.0.0.1:9050",
    "https": "socks5://127.0.0.1:9050"
}
```

Такое решение позволяет в каждом месте **по выбору** включать или отключать проксирование.  

### Схема обхода TOR для локального IP

- **Запрос к локальному Ollama**:  
  ```python
  session.proxies = {}  # не используем никакой прокси
  response = session.post("http://10.67.67.2:11434/api/generate", ...)
  ```
  Благодаря этому Ollama не идёт через SOCKS5 и не выдаёт ошибку.

- **Запрос к внешним сервисам** (например, check IP):  
  ```python
  if USE_TOR:
      session.proxies = {
          "http":  "socks5://127.0.0.1:9050",
          "https": "socks5://127.0.0.1:9050"
      }
  else:
      session.proxies = {}
  response = session.get("https://api.ipify.org?format=json")
  ```
  Здесь мы смотрим на флаг `USE_TOR`. Если он включён, то прокси активируется; если выключен — запрос идёт напрямую.

---

## Настройка и запуск

1. **Убедитесь**, что у вас установлен Python 3, а также модуль `requests` (версии 2.0+) и (при необходимости) `pysocks`.
2. **Установите TOR** (например, с помощью `agents/install_tor.py` из вашего проекта или стандартным методом для вашей ОС).
3. **Проверьте**, что `tor` служба действительно работает:
   ```bash
   systemctl status tor
   ```
   Должна быть активна.

4. **Запустите** скрипт:
   ```bash
   python3 agents/test_local_llm_api_and_tor.py
   ```
   Скрипт:
   - Покажет статус TOR (через systemd),
   - Отключит прокси, проверит IP, сделает запрос к локальному Ollama,
   - Включит прокси, снова проверит IP, сделает запрос к локальному Ollama (уже при «включённом TOR», но всё равно напрямую, минуя прокси),
   - И в конце (опционально) опять выключит TOR-прокси (session-level).

Если вам удобнее **запускать через меню**, в вашем `menu.py` (или другом основном скрипте) есть пункт, который ссылается на `agents/test_local_llm_api_and_tor.py`.

---

## Пример логов работы

Пример вывода (сокращённый):
```
2025-01-22 00:56:09,304 - __main__ - INFO - Текущий IP-адрес: 195.2.75.203
2025-01-22 00:56:09,305 - __main__ - INFO - Начало теста подключения к LLM API
2025-01-22 00:56:09,305 - __main__ - INFO - Отправка запроса к http://10.67.67.2:11434/api/generate
2025-01-22 00:56:10,224 - __main__ - INFO - Статус ответа: 200
2025-01-22 00:56:10,224 - __main__ - INFO - Тест без TOR успешно завершен

2025-01-22 00:56:10,224 - __main__ - INFO - Включение TOR
2025-01-22 00:56:10,760 - __main__ - INFO - Текущий IP-адрес: 192.42.116.192
2025-01-22 00:56:10,760 - __main__ - INFO - Тест c TOR (но локальный Ollama идёт без прокси)
2025-01-22 00:56:10,763 - __main__ - ERROR - Тест с TOR завершился с ошибкой
```

На практике (в **актуальной** версии) мы больше не меняем глобально `socket.socket`, поэтому вместо ошибки «General SOCKS server failure» вы будете видеть, что локальный запрос **работает**. Если по какой-то причине всё же включается глобальная подмена сокета (через `socks.set_default_proxy(...)` без session-level), появится та самая ошибка при обращении к `10.67.67.2`.

---

## Как использовать ту же логику в других скриптах

Любой другой скрипт, в котором нужно:
1. **Иногда** ходить через TOR к внешним сервисам,
2. **Но** при этом локальные или внутренние ресурсы (в диапазоне `10.x.x.x`, `192.168.x.x` и т.д.) **не** должны идти через TOR,

может применять тот же подход **session-level proxies**:

```python
def get_session(use_tor: bool) -> requests.Session:
    s = requests.Session()
    if use_tor:
        s.proxies = {
            "http": "socks5://127.0.0.1:9050",
            "https": "socks5://127.0.0.1:9050"
        }
    return s

def fetch_public_data(use_tor=False):
    session = get_session(use_tor)
    r = session.get("https://api.example.com/data")
    # ...

def fetch_local_data():
    # Локальный ресурс всегда без тор
    session = requests.Session()
    session.proxies = {}
    r = session.get("http://192.168.0.10:8080/internal/api")
    # ...
```

Таким образом:

- **Внешние** адреса используются со скриптом, в котором `s.proxies` указывает на SOCKS5 (если хотим TOR).
- **Локальные** адреса всегда идут напрямую (`session.proxies = {}`).

Это гарантирует, что вы не получите ошибки при запросах к локальным IP, и при этом можете независимо «включать» или «выключать» TOR для всего, что находится **вне** вашей сети.
